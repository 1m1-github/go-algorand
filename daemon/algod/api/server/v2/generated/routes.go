// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"PS6FZGdYC+f9p/8XAAD//y/Gm9gDQwEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
