// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Simulates a raw transaction as it would be evaluated on the network.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.POST("/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"aUdwsJSSnWNV9ncf/38AAAD//xL9q4uEIAEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
