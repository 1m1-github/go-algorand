// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Simulates a raw transaction as it would be evaluated on the network.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.POST("/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
