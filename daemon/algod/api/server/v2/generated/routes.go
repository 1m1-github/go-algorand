// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/boxes/{box-name})
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, boxName string) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Path parameter "box-name" -------------
	var boxName string

	err = runtime.BindStyledParameter("simple", false, "box-name", ctx.Param("box-name"), &boxName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter box-name: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, boxName)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/applications/:application-id/boxes/:box-name", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"LpdSsjOslfzh4v8HAAD//ySIEWLkJgEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
