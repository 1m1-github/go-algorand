// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Simulates a raw transaction as it would be evaluated on the network.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.POST("/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//jDvSxmYgAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
