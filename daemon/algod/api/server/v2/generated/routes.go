// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
