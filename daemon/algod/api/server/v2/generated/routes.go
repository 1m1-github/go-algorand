// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.POST("/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"//+UrUuSWCEBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
