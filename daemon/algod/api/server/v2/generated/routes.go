// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
