// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Simulates a raw transaction as it would be evaluated on the network.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.POST("/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
