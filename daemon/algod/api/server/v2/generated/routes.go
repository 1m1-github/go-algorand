// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.POST("/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
