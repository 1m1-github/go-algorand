// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
