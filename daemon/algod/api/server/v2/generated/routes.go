// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
