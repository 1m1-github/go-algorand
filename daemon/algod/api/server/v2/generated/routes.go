// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Simulates a raw transaction as it would be evaluated on the network.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.POST("/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9aXPctrLoX8Gbe6u83OFI3nKPVZW6T7GdRO/YjstSzl0ivxhD9szgiAR4AFCaiZ//",
	"+ys0ABIkwRlq8ZajT7aGWBqNRqN3fJikoigFB67V5ODDpKSSFqBB4l80TUXFdcIy81cGKpWs1EzwyYH/",
	"RpSWjC8n0wkzv5ZUrybTCacFNG1M/+lEwj8qJiGbHGhZwXSi0hUU1AysN6VpXY+0TpYicUMc2iGOnk8+",
	"bvlAs0yCUn0of+H5hjCe5lUGREvKFU3NJ0UumF4RvWKKuM6EcSI4ELEgetVqTBYM8kzN/CL/UYHcBKt0",
	"kw8v6WMDYiJFDn04n4lizjh4qKAGqt4QogXJYIGNVlQTM4OB1TfUgiigMl2RhZA7QLVAhPACr4rJwW8T",
	"BTwDibuVAjvH/y4kwB+QaCqXoCfvprHFLTTIRLMisrQjh30Jqsq1ItgW17hk58CJ6TUjryqlyRwI5eTt",
	"j8/Io0ePnpqFFFRryByRDa6qmT1ck+0+OZhkVIP/3Kc1mi+FpDxL6vZvf3yG8x+7BY5tRZWC+GE5NF/I",
	"0fOhBfiOERJiXMMS96FF/aZH5FA0P89hISSM3BPb+EY3JZz/i+5KSnW6KgXjOrIvBL8S+znKw4Lu23hY",
	"DUCrfWkwJc2gv+0nT999eDB9sP/xX347TP7H/fnk0ceRy39Wj7sDA9GGaSUl8HSTLCVQPC0ryvv4eOvo",
	"Qa1ElWdkRc9x82mBrN71JaavZZ3nNK8MnbBUisN8KRShjowyWNAq18RPTCqeGzZlRnPUTpgipRTnLINs",
	"arjvxYqlK5JSZYfAduSC5bmhwUpBNkRr8dVtOUwfQ5QYuK6ED1zQ14uMZl07MAFr5AZJmgsFiRY7rid/",
	"41CekfBCae4qdbnLipysgODk5oO9bBF33NB0nm+Ixn3NCFWEEn81TQlbkI2oyAVuTs7OsL9bjcFaQQzS",
	"cHNa96g5vEPo6yEjgry5EDlQjsjz566PMr5gy0qCIhcr0Ct350lQpeAKiJj/HVJttv3/HP/ymghJXoFS",
	"dAlvaHpGgKciG95jN2nsBv+7EmbDC7UsaXoWv65zVrAIyK/omhVVQXhVzEGa/fL3gxZEgq4kHwLIjriD",
	"zgq67k96Iiue4uY207YENUNKTJU53czI0YIUdP39/tSBowjNc1ICzxhfEr3mg0KamXs3eIkUFc9GyDDa",
	"bFhwa6oSUrZgkJF6lC2QuGl2wcP45eBpJKsAHD/IIDj1LDvA4bCO0Iw5uuYLKekSApKZkV8d58KvWpwB",
	"rxkcmW/wUynhnIlK1Z0GYMSpt4vXXGhISgkLFqGxY4cOwz1sG8deCyfgpIJryjhkhvMi0EKD5USDMAUT",
	"bldm+lf0nCr47vHQBd58Hbn7C9Hd9a07Pmq3sVFij2TkXjRf3YGNi02t/iOUv3BuxZaJ/bm3kWx5Yq6S",
	"Bcvxmvm72T+PhkohE2ghwl88ii051ZWEg1N+3/xFEnKsKc+ozMwvhf3pVZVrdsyW5qfc/vRSLFl6zJYD",
	"yKxhjWpT2K2w/5jx4uxYr6NKw0shzqoyXFDa0krnG3L0fGiT7ZiXJczDWpUNtYqTtdc0LttDr+uNHABy",
	"EHclNQ3PYCPBQEvTBf6zXiA90YX8w/xTlnkMp4aA3UWLRgFnLDgsy5yl1GDvrftsvprTD1Y9oE2LPbxJ",
	"Dz4EsJVSlCA1s4PSskxykdI8UZpqHOlfJSwmB5N/2WusKnu2u9oLJn9peh1jJyOIWuEmoWV5iTHeGIFG",
	"beEShjPjJ+QPlt+hKMS43T1DQ8zw3hzOKdezRhFpMYL65P7mZmrwbWUYi++OYjWIcGIbzkFZudY2vKNI",
	"gHqCaCWIVhQzl7mY1z/cPSzLBoP4/bAsLT5QJgSG4hasmdLqHi6fNkconOfo+Yz8FI6NArbg+cbcClbG",
	"MJfCwl1X7vqqLUZuDc2IdxTB7RRyZrbGo8EI7zdBcagsrERuxJ2dtGIa/+zahmRmfh/V+dsgsRC3w8SF",
	"6pPDnNVc8JdAZbnboZw+4TgjzowcdvtejWzMKHGCuRKtbN1PO+4WPNYovJC0tAC6L/YSZRxVL9vIwnpN",
	"bjqS0UVhDs5wQGsI1ZXP2s7zEIUESaEDww+5SM9u4LzPzTj9Y4fDkxXQDCTJqKbBuXLnJX5ZY8efsR9y",
	"BJARif4X/A/NiflsCN/wRTus0dQZ0q8I7OqZUXCt2GxnMg1Q8RaksDotMbropaB81kze4xEWLWN4xAur",
	"RhPs4Rdhlt4YyQ7nQl6NXjqEwElj+iPUjBocl2lnZ7FpVSYOPxHzgW3QGajxtvSlyBBD3eFjuGph4VjT",
	"T4AFZUa9CSy0B7ppLIiiZDncwHldUbXqL8Loc48ekuOfD588ePj7wyffGYWklGIpaUHmGw2K3HViNFF6",
	"k8O9/spQnq1yHR/9u8feYNQeNzaOEpVMoaBlfyhriLKXlm1GTLs+1tpoxlXXAI45lidg2ItFO7E2VgPa",
	"c6bMnVjMb2QzhhCWNbNkxEGSwU5iuuzymmk24RLlRlY3oXyAlEJGTCF4xLRIRZ6cg1RMRKzab1wL4lp4",
	"gaTs/m6hJRdUETM3WukqnoGcxShLrzmCxjQUateFaoc+WfMGN25AKiXd9NBv1xtZnZt3zL60ke+NPoqU",
	"IBO95iSDebVsya4LKQpCSYYd8eJ4LTIwekelboBbNoM1wJiNCEGgc1FpQgkXGaCSUqk4Hx1wcaFtHV0C",
	"OmTNemXv6TkYgTil1XKlSVUSNHj3trbpmNDUbkqCd6oasAjWplzbyk5n3Se5BJoZQRk4EXNndnMGQVwk",
	"RWu99pzIcfGI6tCCq5QiBaWMgmPF1p2g+XZ2l/UWPCHgCHA9C1GCLKi8IrBaaJrvABTbxMCtxS5nq+xD",
	"PW76bRvYnTzcRiqNjmOpwMh45nTnoGEIhSNxcg4SbXafdP/8JFfdvqoc8Kg7SeWEFagqccqFglTwTEUH",
	"y6nSya5jaxq1xCmzguCkxE4qDjygrr+kSlvLLeMZitaW3eA8Vo83UwwDPHijmJH/5i+T/tip4ZNcVaq+",
	"WVRVlkJqyGJr4LDeMtdrWNdziUUwdn19aUEqBbtGHsJSML5Dll2JRRDVtZ3DuTb6i0NrgLkHNlFUtoBo",
	"ELENkGPfKsBu6FUcAMToYXVPJBymOpRTuzKnE6VFWZrzp5OK1/2G0HRsWx/qX5u2feKiuuHrmQAzu/Yw",
	"OcgvLGatP3lFjQyMI5OCnpm7CSVaa2Luw2wOY6IYTyHZRvnmWB6bVuER2HFIB5QJF7ESzNY5HB36jRLd",
	"IBHs2IWhBQ9oNm+o1CxlJUoSf4XNjZtFuhNELSQkA02ZkbaDD8jAkffW/Yn1GXTHvJqgNUoI7YPfk0Ij",
	"y8mZwgujDfwZbNBU+sY6o08CF/YNSIqRUc3pppwgoN7FZS7ksAmsaarzjbnm9Ao25AIkEFXNC6a1jS5o",
	"C5JalEk4QFTB3zKjM7FYR67fgTE2n2McKlhefyumEyu2bIfvpCO4tNDhBKZSiHyEKbqHjCgEo0zVpBRm",
	"15kLZvERD56SWkA6IQbtazXzvKNaaMYVkP8WFUkpRwGs0lDfCEIim8Xr18xgLrB6TmeUbjAEORRg5Ur8",
	"cv9+d+H377s9Z4os4MJHgJmGXXTcv49a0huhdOtw3YDGa47bUYS3o+XDXBROhuvylNlO1d6NPGYn33QG",
	"r80l5kwp5QjXLP/aDKBzMtdj1h7SyIqq1e6147ijjBrB0LF1232XQixuyJAWjwBA5cQ59U0rsqi4BapS",
	"Th1BP5c3aIjFtI7ysNHdBwRDAFbUW+Pcnw+ffDeZNq77+ru5k+3XdxGJkmXrWIBGBuvYnrgjhtrUHaN6",
	"bBREvWLImMUiEqMF8ix3K+uwDlKAOdNqxUozZBNPstHQikX9v3f/4+C3w+R/aPLHfvL03/befXj88d79",
	"3o8PP37//f9r//To4/f3/uNfo2ZFzeZx8+fPZpfEgjgWv+ZH3DowFkJafWzjxDyx+PxwawmQQalXseDP",
	"UoJC1miDOEu9ajYVoGNDKaU4Bz4lbAazLovNlqC8MSkHusAgRNQpxBinaH0cLL154giwHi5kFB+L0Q+6",
	"+JA28TAfs6LKb4p7LyjLKwnDpv7T098WxenpO/KjbeldR1N/Y4WQXjThuAsnWlYSPbskZ0bXl4JmKVU6",
	"aqhEjsWXSR0UpKLgFMqA85/uUqV800kgGQsDmUNKKxsN50QwB0ETlqRmEfWmQwVdFEYXMmbzrcnVSuAh",
	"VpdSVCVR9bZbKqiMInsDIqwdiMj2qfImG2W/ikUYP+3YpdooDUXf6mm7/j6g8731GlOPtQqeMw5JIThs",
	"oilDjMMr/BjrbYWegc4ofg717WqULfg7YLXnGbOr18Uv7nZwy7+pwxtuYPO743YM3mHkOBrsIC8JJWnO",
	"0JwnuNKySvUpp2gwCIg24lT0ZpBhE9Iz3yRus4qYlNxQp5wqg8PajBDlLwuI8LcfAbwlSVXLJSjdUZ0W",
	"AKfctWKcVJxpnKsw+5XYDStBomdvZlsWdEMWNEeL1x8gBZlXus2kUPRRmuW5s76baYhYnHKqzU2kNHnF",
	"+Mkah/NxpJ5mOOgLIc9qLMQFlSVwUEwl8dv/J/sVhQC3/JUTCDDbyH72t87nvv097LHwSwf50XOnaB89",
	"R22qsbv3YP9sxtiC8SRKZEY6LhjHKP4ObZG7Rif0BHSvseC7XT/les0NIZ3TnGVGgr4KOXRZXO8s2tPR",
	"oZrWRnRsa36t72LBI0uRlDQ9Q4FismR6Vc1nqSj2vIFhbylqY8NeRqEQHL9le7Rke6qEdO/8wQ5t5xr8",
	"ikTY1cfpxHEddePmODdwbEHdOWurtv9bC3LnpxcnZM/tlLpjY7Ht0EEQbcQm5OLEWm5Ls3ibS2iD0U/5",
	"KX8OC8aZ+X5wyjOq6d6cKpaqvUqB/IHmlKcwWwpy4EPPnlNNT3mPxQ+m+wZBf6Ss5jlLyVl4FTdH06Zw",
	"ReU+QyBG8uv6wPoXp5sqekbtBMkF0ytR6cTlqCQSLqjMIqCrOkcBR7YZZttmnRI3tqVIlwPjxo+zalqW",
	"qhuy3F9+WeZm+QEZKheQa7aMKC2kZ4KGM1pocH9fC6d4S3rhE5wqBYq8L2j5G+P6HUlOq/39R0BaMbzv",
	"Ha8xNLkpoWU9vFJIdddyiAu3AhWstaRJSZcDUr8GWuLu40VdoJSc5wS7tWKHfaQNDtUswONjeAMsHJeO",
	"g8TFHdtePtk4vgT8hFuIbQx3atw/V92vIJr4ytvViUju7VKlV4k529FVKUPifmfqHMSl4cneJ2f0IFSr",
	"bLrmHEi6gvQMMswcg6LUm2mru3f7uhvOsw6mbIalDXfENCA0tM6BVGVGnQzQ0QgNhhVo7ZNQ3sIZbE5E",
	"k0V0mQSMdlqAGjqoSKnBZWSINTy2bozu5rsQAlRWy9JH12MkqSeLg5oufJ/hg2xvyBs4xDGiaIWtDyGC",
	"yggiLPEPoOAKCzXjXYv0Y8sz4s3c3nwRY5/n/cQ1aaQ2FwYQrgaj8e33AjBdW1woMqcKMiJcprENfQ+4",
	"WKXoEgYskKGte2SAecs+joPsuveiN51YdC+03n0TBdk2Tsyao5QC5oshFTQWd4I//EzWnWItIAQLiDiE",
	"zXMUk+q4E8t0qGz5HGxFhCHQ4gQMkjcChwejjZFQsllR5ZOgMVfcn+VRMsAnTOXYlrl3FMQtBAnhteXK",
	"89zuOe1Z713+nk/a85l6oel+RNbddOJC6WLbITgKQBnksLQLt409oTRpJc0GGTh+WSxyxoEksRAIqpRI",
	"mc1ib64ZNwcY+fg+Idb2REaPECPjAGx0E+LA5LUIzyZfXgZI7tJiqB8bHYzB3xCPB7VBbkbkEaVh4YwP",
	"hCd6DkBd3Ex9f3Wit3AYwviUGDZ3TnPD5pwpvRmkl0eGYmsna8w5qu8NibNbTH/2YrnUmuxVdJXVhDKT",
	"Bzou0G2BeLsoEdsChfhyqm+Nq6G7dMzUA9f3EK7uBhloVwKgY4loijQ5zW+nhta+m/s3WcPSp01KtY/P",
	"jdH+EP1Ed2kAf31DcJ0z9qZ7XUeV9LYDu50uF8hPMVZszkjfNNo3wCrIASXipCVBJGcxg7kR7AHZ7bHv",
	"FmjumJRH+eZeEBUhYcmUhsZ0ZW4lb4v93E5PikUAhFgMr06XcmHW91aImkfbZFPrxA2X+dlXcC40JAsm",
	"lU7Q7hddgmn0o0KN8kfTNC4otOMubD0clsV5A057BpskY3kVp1c371+fm2lf10YYVc3PYIPiINB0ReZY",
	"vykajbVlahuwt3XBL+2CX9IbW++402CamomlIZf2HN/Iuehw3m3sIEKAMeLo79ogSrcwSLz4n0OuY3lr",
	"gdBgD2dmGs62mR57hynzY29TlAIohu8oO1J0LYG2vHUVDGNQjLrHdFD+qJ88MnAGaFmybN0xBNpRB9VF",
	"eilt36eXd7CAu+sG24GBwOgXi0+WoNqVBBrp1hay4uHaZqMwc9LO9w8ZQjgVU74MYx9RhrSxVtguXJ0A",
	"zf8Km7+Ztricycfp5Hp2wxiu3Yg7cP2m3t4ontEhZu1ILTfAJVFOy1KKc5onzro6RJpSnDvSxObeGPuZ",
	"WV3chnfy4vDlGwf+x+kkzYHKpBYVBleF7cpvZlW2aMHAAfFl3ozC42V2K0oGm18nk4cW2YsVuJJagTTa",
	"KwHSWNuDo+gstIu4X36nvdU5BuwStzgIoKz9A43tyroH2i4Bek5Z7o1GHtoBHzoublwdmShXCAe4tmsh",
	"8BAlN8pueqc7fjoa6trBk8K5thT9KmxdO0UE7wbmGRESbVFIqgXFAh7WJNBnTrwqEnP8EpWzNG5g5HMM",
	"GuPWcWQaE2w8IIyaESs24IfkFQvGMs3UCEW3A2QwRxSZvhjMEO7mwhUkrjj7RwWEZcC1+STxVHYOKlZM",
	"cabm/nVqZIf+XG5ga55uhr+OjBEWr+neeAjEdgEjdFP1wH1eq8x+obU5xvwQ2OMv4e0OZ+xdiVs81Y4+",
	"HDXbkKFV290U1g/u8z9DGLbW3O7ixV55dVV0BuaIFiNmKllI8QfE9TxUjyPJC75cD8PY2T+AjwiSbKw7",
	"TU3lZvbB7R6SbkIrVNtDP0D1uPOBTwpLo3jzLOV2q21t0FZcSJxgwliuPTt+QzAO5l78W04v5jRWN8YI",
	"GQamw8b72TIka0F8Z497Z/NmroLSjASO1Lots2l9Jcgmr6ifQn5FgcFOO1pUaCQDpNpQJpha51euRGSY",
	"il9QbkvMmn72KLneCqzxy/S6EBKTclXc5p1BygqaxyWHDLHfTmLO2JLZAquVgqCCpxvIVqa2VOSqoFr/",
	"coOaowXZnwY1gt1uZOycKTbPAVs8sC3mVCEnrw1RdRezPOB6pbD5wxHNVxXPJGR6pSxilSC1UIfqTe25",
	"mYO+AOBkH9s9eEruos9KsXO4Z7Do7ufJwYOnaHS1f+zHLgBXSXkbN8kWYdh2nI7RaWfHMIzbjTqLppja",
	"8vfDjGvLabJdx5wlbOl43e6zVFBOlxAPkyh2wGT74m6iIa2DF57Z2s1KS7EhbCCAHjQ1/Gkg5tOwPwsG",
	"SUVRMF04z4YShaGnpjynndQPZwtBuxpSHi7/ER2EpfePdJTIz2s0tfdbbNXoxn1NC2ijdUqozcTOWeO6",
	"92XfyJGv54BFtepaWhY3Zi6zdBRz0JO/IKVkXKNiUelF8heSrqikqWF/syFwk/l3jyOFxNq1g/jlAP/s",
	"eJegQJ7HUS8HyN7LEK4vucsFTwrDUbJ7TYx1cCoHPZnxaDHP0bvBgtuHHiuUmVGSQXKrWuRGA059LcLj",
	"Wwa8JinW67kUPV56ZZ+dMisZJw9amR369e1LJ2UUQsaq+zTH3UkcErRkcI6Ba/FNMmNecy9kPmoXrgP9",
	"l/U8eJEzEMv8WY4pAj9ULM/+1uSMdGoxSsrTVdTuPzcdf29qZddLtuc4WkxmRTmHPDqcvTN/93dr5Pb/",
	"uxg7T8H4yLbdGot2uZ3FNYC3wfRA+QkNepnOzQQhVttB9HXUZb4UGcF5msolDZX1y0YGddT+UYHSsdRN",
	"/GAjP9C+Y/QCW8aLAM9Qqp6Rn+xbNysgrcIKKM3aLDjISA7ZEqQzPFZlLmg2JWackxeHL4md1faxhV9t",
	"GbElCnPtVXT0+qDM0bgYQl/DNR7fPH6c7QGXZtVKY50TpWlRxlJXTIsT3wDzY0JbJ4p5IXZm5LmVsJWX",
	"3+wkhh4WTBZGMq1HszweacL8R2uarlB0bXGTYZIfX//OU6UKngeoq/3WlYrw3Bm4XQk8WwFvSoTRLy6Y",
	"sk+cwDm0s2Xq1DGnOvnsmfbyZMW5pZQoj96W2ngVtHvgrEPbm0OjkHUQf0nBxZaPvGw5wGPsFS390a0t",
	"2HsXwOaW14Vq/dNVKeWCsxQLbwSPqtQgu+dSxvgKRtQo6Rqj/BF3JzRyuKIVDetwIofFwRqHnhE6xPWN",
	"lcFXs6mWOuyfGt/lWFFNlqCV42yQTX1hTmcvYVyBqzyFL+cEfFLIlv8FOWTUpZfUpt9LkhHGzg8IwD+a",
	"b6+deoRBpWeMoyDk0ObiV61FA19z0EZ6YposBSi3nnZiufrN9JlhkYIM1u9m/vUHHMO6L8yyra+uP9Sh",
	"99w5T5lp+8y0JTbqsP65FaZoJz0sSzfpcNnWqDyg13wQwREPTOJN4AFy6/HD0baQ21aXO96nhtDgHB12",
	"UOI93COMuoRpp2bzOc0rS1HYgthQl2h+JeMRMF4yDs3bJJELIo1eCbgxeF4H+qlUUm1FwFE87QRojl66",
	"GENT2plorztUZ4MRJbhGP8fwNjbVVwcYR92gEdwo39RPohjqDoSJZ/gWk0Nkv5YqSlVOiMow7LhTXTXG",
	"OAzj9gUP2hdA/xj0ZSLbXUtqT85lbqKhTLJ5lS1BJzTLYiX7fsCvBL/6chCwhrSqS56VJUkxY7udwt6n",
	"NjdRKriqii1z+QbXnC4VMTn6NU6gfFx1M/iMIPs1rPf5izdvXzw7PHnx3N4XRi23qWRG5pZQGIZo9Fil",
	"wYjOlQLyPkTje+z3vrPgOJhBVeUI0YaVnT0hYkD9fIP/xsqSDROQ86lfOqrLO9Cx46XF+/ZIPeHcHL1E",
	"sWUyHhN49V0fHc3UVzuPTf8bPZC5WLYB+cz1g7Yx43CPYmz4hbnfwizwXq09ewPWSdoYQyX8Aw2o3dbp",
	"hW3miTdur/ge2u7rAjzbrSfDVfOneEcPRFIGVZOoFQOsM2gonjIdDP+l2mXhaEq2ckosdR8bwQZj2BL7",
	"9nXOqCFsKADDxl+Yz73e4wTYnjqAY29FqI/s6QP0Vx82SErKnKezYRZ9zLoA437I95jQw2aDu4twYbs4",
	"SGwlvZqa2ymkF7YdpB7Y0oez8en/h7UbGZ1bWLh+CdxVrm8HZI4OC1ssINXsfEeY/H8a1aIJwZ565cM+",
	"ixJEzbM6zMg/4npJnagBaFsU+1Z4ghoj1wZnKEj2DDZ3FGlRQ7QW49QT6lWySxEDWH8lMSQiVMxNY60l",
	"znLOVE0ZiAXvFrXdoSmANlgEO0j6uOJcniQJDRNBtkx5LmLq1qi5TNdLpUdhxMxQJH2/DO3w7fUcq/6q",
	"+gGD+pXWQBQ1WnWvtpvLbsWkhtpA6PNcQfnffAaTncW+/tuU6UZz7AWVmW8R1S+86pIMxKZ1o71tUD2L",
	"A72oZ2ZNEEs/4DlSFQJDldJcYDG3oXivdtxI+IAYesfQkoPF5RCuBUhXnl/7x5UTLXzQyzY4tqHCPXZ1",
	"FSSowUqXFrjB/Oi3TQI4lsKi9mlt5/kLF2iUDWqgk0Ga9vCc25D9zH73Eb6+FNIINcrRa7Izz9qHLzHV",
	"Q2JI9QvibsvdkcNXUVUY5/b1ExXL2eYGlaHJr5Qiq1J7QYcHo1EMx1ZE2MJKolJ+2l9lT2DLsT7IyyAP",
	"4ww2e1ZoSleUN4Va2sfaFvC0awjyHju7faNaXFxgzZd2AcsbgfNLakLTSSlEngzY+I76qefdM3DG0jPI",
	"iLk7vON/oBA2uYumpdqJc7Ha+FTrsgQO2b0ZIUaXKkq98f6cdtG1zuT8jt42/xpnzSpbDcIpabNTHo9Z",
	"sY/VX5O/+WG2czUFhvldcyo7yI7c7vVA2rukF5Gy8GNf/ot4WLqluhuislDEpJQrJvqNOt99RS1C+mGK",
	"xg7956yl1dmyQh2vipBww9pdYE6+pHbXTz4ZuzxcB3K1SkF/naM3oIXbAdyPQXxjmugjd9iioOdjLArx",
	"EiimO5o0LEKwfhBBUMn7B++JhAXWExTk/n2c4P79qWv6/mH7s9G+7t+PnszPZsxoPTDo5o1RzN+GvPDW",
	"0zwQ8NHZj4rl2S7CaIXvNLU9MUDldxfo9EWqi/5uVeT+UXWFFi9jRu1uAiImstbW5MFUQWDOiJgc120W",
	"fQJSQVpJpjeYf+U1KvZ7NK/9p9oI416trSP2XcC4FmdQZ/A1JpvmSf+fhH0ysjB3PRqxNb6B8WJNizIH",
	"d1C+vzP/d3j0l8fZ/qMH/z7/y/6T/RQeP3m6v0+fPqYPnj56AA//8uTxPjxYfPd0/jB7+Pjh/PHDx989",
	"eZo+evxg/vi7p/9+x7+nbwFt3qr/LyzBmxy+OUpODLANTmjJ6qdvDBn7cp40xZNodJJ8cuB/+t/+hM1S",
	"UTTD+18nLphwstK6VAd7excXF7Owy94SdbREiypd7fl5+k+OvDmqA51sggruqI1hMaSAm+pI4RC/vX1x",
	"fEIO3xzNGoKZHEz2Z/uzB1g1uwROSzY5mDzCn/D0rHDf9xyxTQ4+fJxO9lZAcyyob/4oQEuW+k/qgi6X",
	"IGeurqn56fzhno+T2Pvg9NOPZtRlLDPNhmyFr3L3yn06Wxf6vWxIVqt8lnLVnKZ1UTUnPvIMI2msymdY",
	"W42so6wpoHIUPPXs0shsXv3Bb5Ey0wu2rGTnsa7amu8qLjJF7MurkryyNvc3ND0Lo1WQIP9Rgdw0BONY",
	"WZgQ7gtguZiWQi3LtgO4sfTHnvWJ1U3Fmc0+B5Ram4oaTqRlBSEkDV81vHI/efruw5O/fJyMAATtlu7x",
	"6Pc0z9/b19Rgjcaf9jvuahop9oRC3bQxPXSeap+iB7v+GtbzrNu046bec8Hh/dA2OMCi+0Dz3DQUHGJ7",
	"8A4D2pES8BA93N//BM+9T1ujeJL4ou/GP77BhbY9aNdebne43qJ/oBnWWASl7VIefLNLOeLoOjAcn9gb",
	"7eN08uQb3psjbngOzQm2DLLF+rfIr/yMiwvuWxpppioKKjcoqwSFYEOp9OPgbbUXFq3b+9AyLGfXust6",
	"9TqPnu+43u6oIabYL6PQqYlnvtdV39D06Ar/wZopre7NyE9hb2TMmJVgY/4ryZv3xUopzllmWKzzyfnk",
	"zQa2OypM2IhetoG2fnvvftJ797BtdWjl4ceAaZH4Vph6nqfrXnz9KLFOSfMrlQwPqu9doYbRJ62r2n2J",
	"fujJzxEM9hZ3Q8+lDog3Aby1pNOumvjp+a7V34JronUffEKu/I0La69obugkWG4nYt0Wp7gV4v5phLg6",
	"GMG+TIL1mLaJdVh0de+DryVyA6Kcq6UyQogLNd2gb1Dr4m6HU9yb2cIgYZursQMXWLBTPMMKL7eC2acW",
	"zPqlkWJgNAVvvpwwhjCsmtpJl3kOpFXq+FI1nr5R6eufGFmD4paBdLegdQXe2BOiHCf+ZDzzTyk8OaTd",
	"ik3/1GKTjeXbIji16pa5wM9h2QmCt+qDl19agWfzjafDKVFCuvCnUjIhmd5MCeMkA3P20GMoJKZoN6/e",
	"uyAj4PjfV4f/haGnrw7/i3xP9qe1CIYZbJHpbXBPWwb6CXQ/hk39sDmsxYGtstBXI2Cc1EgKoktD1Gvh",
	"S48h0gq6/n4IZWvrV4yJZwVdT7ZKItNvR1q8rtDUyT3tU5F7chSd/v6ZnHZIlSKwpqnON4Sq4GFpfI/f",
	"1w1rixtalEk4QDTfaMuM/hWOWNbYZaO6Ign++NrFdvhOOjWWWuhw9fnwyZvdgkkPGVEIribl3e7uN7u7",
	"fbGUlMKcaYYFJJr7xN9VLSCbtxgcuAMBqzPy36LCYBf71BjEip/iDBjc6+d0AmhQvTjHh95q7Ny/3134",
	"/ftuz5kiC7hADko5Nuyi4/79P4HIuq5rTlLCBU84voR1DiSIkLuVW79qufXJ/qNvdjXHIM9ZCuQEilJI",
	"Klm+Ib/yukjP9cTymudUPCibtJX/9CLlGyk6EN+v5bvu+qaZbiTDVuJUYEKoHyx0uvK0efHA6PJYXMUn",
	"rKupd51g4J/1qtj9mPYcK7OYkB54cH7YHD0fI5d/I47Q0UW+IvdafG8+9Q0Qjad5+3niacYx08f7jz8f",
	"BOEuvBaa/Ijmsk/M0j+p7SBOVgGzubRHpfGYhKzFJSJuZSrmhE5dYVasFLohdaKQ4SeWEdqnGfpcw8ww",
	"ll98xfb5EY8SR+iyi95bvnDLF67FF7oE1XAETLdXex/QVRCyg96R/MG0/BO5GAN/ixSFd7gIsgCdrmwZ",
	"gm5aTISt+FqBwzxlW0X9G/b/IdCRUlW4Fpf6gZXeRyYEYsefbSbGx+kkBRkhvl98PRzzmS0wrbOuA+kf",
	"jkB3DvO1lOsyyq7YPFM+5txVvSFmFy8F5bNm8n6aDqLlJnyGtwi+HIJ7TO2Fq2ptj5dbxJ8hKt2XPE7I",
	"axSH8ID7Moh/RrPHp7yRP/WCXgsO1i9tJFZLi7cuyFpcwLdnECm+CoJ1PLrnbOOiQ9vp+EGvWfZxry7T",
	"MyRUvMEGO4SK5qZmzYufbfMKLUugUl35kt7tDjvpzHj0PIzTaFUVqusJRUAxeLmkJ/HfJiOlGUz4EQuy",
	"ompFFhW3gNZvS2HIig+iEItpbaw1p0EsDsgpv0/Uij558PD3h0++838+fPLdgDxm5nH5x32JrBnIfLbD",
	"jBHL/rxux7YoUSPv4HNv5eV2aDph2TpaQgTWvhJSeC6c7ROZwx1FSroZrDw0UMTrFciz3D/P3nbykALM",
	"hapWrPwSz82zefzFpZ/NLokFqeugH/Efav55DpIt8Nmwmi985sowEiCDUq+2lmSwr56VetVsKrh3OZly",
	"pW9KKc6BTwmbwazrDMuWTUnhHOiiLp0ixJhQtYCXGHrzxBFgPVzIGFHzTYx+MB3SlZj73EaVJqTLXmYe",
	"ebJzr3xRi4v+IhaX14InKI8B1143aKHly1lfsNrNNDBw1i9LcKHRsCkkipEh21KzUQIYDDqbWjzQhk4O",
	"krETx1Kq01VV7n3A/2DlgY9Njr99RmXPGmK3SWTHtsWNhtjYMYlscxtf7MIZh8WCvGKpFIdYFcldI2qj",
	"NBT9RzZt19+3PdARvXIEzxmHpBA8VifjF/z6Cj9G6y6h236gMwZQDPXtPo3Ugr8DVnueMazuuvidfR1G",
	"3mspLJ3VSijrMEWM50D6b05Lq/Btc0xaP+99aP3p/CWupVpVOhMXQV9b12Lr2bItbvRsvRYZ2HHbpWRi",
	"8aNcZODKb/SPVM014hKpx2/TriMcpLRarrR9JDL6Am3dMaGpPQq2dqzaVWzTtvJF5c6B0FwCzTZkDsCJ",
	"mJtFt4sWE6rqV3+ROCxvjNeMbOAqpUhBKciS8HWobaDVRU1Q8tFb8ISAI8D1LEQJsqDyisBaJrEd0O6z",
	"iDW4taXQ8YE+1OOm37aB3cnDbaQSiGeIqNGIoszB6TQRFI7ECcra7BPvn5/kqttXlfgAUaTqqf16wgqs",
	"28EpFwpSwTM1XJt417HFasTBWhTYN3f9SYm+62IGHrhaX1Kl3ftXrRKOQU1rM8WWYspDBcnMyH+ry5H1",
	"xk4Nv+SqUs3TYFb2giz66iqst8z1Gtb1XGIRjF0Ld/ZF6F0jD2EpGL9+LCyojqwDK5YZLrI4TIKhThTr",
	"o7IFRIOIbYAc+1YBdkMLywAgTDWIrkuetikneK1ZaVGW5vzppOJ1vyE0HdvWh/rXpm2fuFzyAPL1TIAK",
	"BW8H+YXFrH0HcEUVcXCQgp45mX3pYvj7MJvDmCjGU1fSfSg/ixVwbFqFR2DHIe2KfeHxb52zzuHo0G+U",
	"6AaJYMcuDC04Jmh+FWLhZfW+rt3uE5rK24J2IF41gqb9e++CMp0shHTl8vGl+YjXvVONizKtnPpntWIt",
	"nKnbvVVvGYobJ3gFU4UB0BYEn4Rjdr8fc2Om+lHIUU7+xh6vBTELIxXXzGdSm/NWy5hfn8f8Vnq+lZ5v",
	"pedb6flWer6Vnm+l51vp+VNLz18mapckiefT3jUcS8gik29Swv+Gcp4+Z5JSI/TXIj8qCUZEN+d4azSP",
	"BprvubenMVoh+iKpTQsI37FOzXSMkzKnRhqCtfbJ6WROFXz32Mdk1G9g2vL9hteYBo8ekuOfD32gwsp5",
	"0ttt7/qX5ZTe5HDPRT3W9bV9+CNwii9uYvQj9dpP6gJKrDC/YDkQZXD1Als/h3PIjSRvnZ/E6CJ97egE",
	"aP7M4WaHctSqoGxGez9t6WQObQUtvcjj10oVoRjU0imAvKC5Gq6AbMcraBlL76/5tFWbkDX8ILJNh9zN",
	"ru3hBrYJvYlTYJzKyBvQffLukYYW+A68e9S8p/d9vPGgmj7R9slsF4XFn5KJv9W8jcqHnxI3G9YbykY0",
	"LTp0Ei3/342dmNQAjnEYGnr2e0LcI9Rf9LYiCJE7Yg1n/moST7pv6zmmgW2NQOVYz7eaJOIRHz29ePan",
	"/u0xwrQijuLWiWm0BJ443pLMRbZJWpypfcE0T/LuvGRC1oiHqb5X6hfuB6+gL3NDBM8+T7ax25Ae1onj",
	"rQOM1waIjWO7NbZwRMd5A4x/au47xCFDEIhjPTHduVu97JL8LHju+Zan3fK04DR2LnvGXWxil4nMrsbT",
	"8IX0YXb2wj4YqEh4SO+qe4ZlIUbXumW5z2BeLZf2lbyuFRqraNWPPX4ZLmeXO5bBXY447OB16ul1sya6",
	"w/UZRxBUd1dIspSiKu/ZmoZ8gwbOoqR8450aRvMvqtw9fouZXjfLQ+sXG3tyozeuDdvl3njzW2B9crdo",
	"+3eLFnzn0e4vZKTiGcj4c2rrziNZuzF+suYNB976hJZ/TLC3OjfvGO7vd9llCNSOnNI+rWoPVOswuThl",
	"e3Jnt+nV/xw3whtbO3SAwfajbBuGsPtikAHLwpuhU2zLXw1tfvqWXoSlu25KaByvra8A78Rae41UJjNi",
	"pBQ0S6lCowYHfSHk2SeWJfX6KGJFRjCxwmQ/8cToJLOdQiWOO0qkbOd6ea28mhdM2Vf5vqxw2WQTHLqE",
	"3RY2bg27fxbD7g/+8ClC8YHfzuG0Phw8kyPYFL3Qax7lUnulrVA9FL8cHAhXy/pGIzF6w7cDMoL60Nah",
	"DHlJKElzhu5mwZWWVapPOUWHVuf1406whnfTDYtSz3yTuE814vJ0Q51yI1QtSO3miopUC4g4sH8E8BKb",
	"qpZLULrDiRcAp9y1YpxUnGmcCx+TTmxcv7muDUef2ZYF3ZAFzdEj+wdIQeZGiQirlqF7SGmW5y46xExD",
	"xOKUU01yMEz/FTMCnRnOexDqiCdLdzUWBh7Jt89TJnHr7E/2K+bQueV7LwA6K+xnn+0y/TKPyCYsG4T8",
	"6LmrKHr0HIvENXEhPdg/W7BAwXgSJTJz47v4qi5tkbtGxvMEdK+JMHG7fsqNMK0FQUZP9dXIoevU7Z1F",
	"ezo6VNPaiI7v16/1XayaxVIkRmWkS/P7kulVNcdnXH2Vi72lqCte7GUUCsHxW7ZHS7anSkj3zh/skA+u",
	"wa9IhF3d3tx/HpdsSAfmtNQbjy8ndPd+4F6+gQLuX3fV9p0Bp7c10m9rpN9W0b6tkX67u7c10m8riN9W",
	"EP9nrSA+2yohuqpbO2v66p5pkxIJqZ25ZuBhs1b1375XkukZIScrw/+puQPgHCTNSUqVFYy4jXsu2HKl",
	"iarSFCA7OOVJC5JUFG7iu81/rZp7Wu3vPwKyf6/bx9otAs7b74uiKn5CVxP5npxOTie9kSQU4hxcLVBs",
	"nlUY/mJ77Rz2f9Xj/iJ7W1fQjTWurGhZgrnWVLVYsJRZlOfCKANL0YnW5gK/gDTA2bpHhGlbdh3xiVHu",
	"LiaGumoiMaG7f79f4tHIw251ms9a1uzPK2Bv41P9Dbs5Hrh17B5DvGUZn4NlfHGm8SeqwHpbbPUrW1Do",
	"SG1VU7+GJFU/IxqxOw3ISC5uB4ad8ceuxdflke94++plXM/9PqLW9YKyvJKQuIrR/W06Pf1tUZyeviM/",
	"2pa+tvTUq4Eh6BeiyjPLz8zAkJGsktYImrNzaEIMom4S9LnzZaLYklNtxIEoOIUy4PynExQo37TF69Ew",
	"kDmktFIQ2DUcBKSBYBZJh+so+V0URhcyRse3wVT22g2xitEppAlJG8HIP3X56+1xCbu581ehc395Pfnb",
	"0W0924yFJ1AjfLhzNwcC5zSv0FAk+DXiFqyj0LAAhATSSjK9Qd2Fluz3MzD/f2ckdAXy3Ks1lcwnB5OV",
	"1uXB3h6+ZLUSSu9NjNLRfFOdj+Z00qUdwcFSSnaOVfDfffz/AQAA//+XTdrVwCEBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
