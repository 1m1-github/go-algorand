// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"w1DCzTwBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
