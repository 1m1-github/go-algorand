// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
