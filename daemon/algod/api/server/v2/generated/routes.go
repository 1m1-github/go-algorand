// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.POST("/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
