// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/boxes/{box-name})
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, boxName string) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Path parameter "box-name" -------------
	var boxName string

	err = runtime.BindStyledParameter("simple", false, "box-name", ctx.Param("box-name"), &boxName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter box-name: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, boxName)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/applications/:application-id/boxes/:box-name", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"reQPF/8/AAD//2W6+VxeJgEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
