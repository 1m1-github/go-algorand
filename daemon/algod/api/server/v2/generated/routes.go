// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
