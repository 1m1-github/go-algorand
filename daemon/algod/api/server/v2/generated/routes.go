// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.POST("/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
