// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"//7CjsUWKAEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
