// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
