// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/boxes/{box-name})
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, boxName string) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Path parameter "box-name" -------------
	var boxName string

	err = runtime.BindStyledParameter("simple", false, "box-name", ctx.Param("box-name"), &boxName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter box-name: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, boxName)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/applications/:application-id/boxes/:box-name", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"f7j4/wEAAP//v1ik3qgnAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
