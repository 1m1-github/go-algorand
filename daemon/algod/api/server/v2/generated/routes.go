// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/boxes/{box-name})
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, boxName string) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Path parameter "box-name" -------------
	var boxName string

	err = runtime.BindStyledParameter("simple", false, "box-name", ctx.Param("box-name"), &boxName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter box-name: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, boxName)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/applications/:application-id/boxes/:box-name", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9aXPbuLLoX8HTvVVZrig729wTV03d58SZGb+TZFKx59xlnDeByJaEYxLgAUBbmjz/",
	"91doACRIgpK8xFmOPyUWsTQajUbv+DRKRVEKDlyr0d6nUUklLUCDxL9omoqK64Rl5q8MVCpZqZngoz3/",
	"jSgtGZ+PxiNmfi2pXozGI04LaNqY/uORhH9UTEI22tOygvFIpQsoqBlYr0rTuh5pmcxF4obYt0McHowu",
	"1nygWSZBqT6Uv/J8RRhP8yoDoiXliqbmkyLnTC+IXjBFXGfCOBEciJgRvWg1JjMGeaYmfpH/qECuglW6",
	"yYeXdNGAmEiRQx/Ol6KYMg4eKqiBqjeEaEEymGGjBdXEzGBg9Q21IAqoTBdkJuQGUC0QIbzAq2K09/tI",
	"Ac9A4m6lwM7wvzMJ8Cckmso56NGHcWxxMw0y0ayILO3QYV+CqnKtCLbFNc7ZGXBiek3Im0ppMgVCOXn/",
	"00vy5MmT52YhBdUaMkdkg6tqZg/XZLuP9kYZ1eA/92mN5nMhKc+Suv37n17i/Edugdu2okpB/LDsmy/k",
	"8GBoAb5jhIQY1zDHfWhRv+kRORTNz1OYCQlb7oltfKObEs7/RXclpTpdlIJxHdkXgl+J/RzlYUH3dTys",
	"BqDVvjSYkmbQ33eT5x8+PRo/2r34l9/3k/9xfz57crHl8l/W427AQLRhWkkJPF0lcwkUT8uC8j4+3jt6",
	"UAtR5RlZ0DPcfFogq3d9ielrWecZzStDJyyVYj+fC0WoI6MMZrTKNfETk4rnhk2Z0Ry1E6ZIKcUZyyAb",
	"G+57vmDpgqRU2SGwHTlneW5osFKQDdFafHVrDtNFiBID15XwgQv6epHRrGsDJmCJ3CBJc6Eg0WLD9eRv",
	"HMozEl4ozV2lLndZkeMFEJzcfLCXLeKOG5rO8xXRuK8ZoYpQ4q+mMWEzshIVOcfNydkp9nerMVgriEEa",
	"bk7rHjWHdwh9PWREkDcVIgfKEXn+3PVRxmdsXklQ5HwBeuHuPAmqFFwBEdO/Q6rNtv+fo1/fEiHJG1CK",
	"zuEdTU8J8FRkw3vsJo3d4H9Xwmx4oeYlTU/j13XOChYB+Q1dsqIqCK+KKUizX/5+0IJI0JXkQwDZETfQ",
	"WUGX/UmPZcVT3Nxm2pagZkiJqTKnqwk5nJGCLn/cHTtwFKF5TkrgGeNzopd8UEgzc28GL5Gi4tkWMow2",
	"GxbcmqqElM0YZKQeZQ0kbppN8DB+OXgaySoAxw8yCE49ywZwOCwjNGOOrvlCSjqHgGQm5DfHufCrFqfA",
	"awZHpiv8VEo4Y6JSdacBGHHq9eI1FxqSUsKMRWjsyKHDcA/bxrHXwgk4qeCaMg6Z4bwItNBgOdEgTMGE",
	"65WZ/hU9pQp+eDp0gTdft9z9meju+tod32q3sVFij2TkXjRf3YGNi02t/lsof+Hcis0T+3NvI9n82Fwl",
	"M5bjNfN3s38eDZVCJtBChL94FJtzqisJeyf8ofmLJORIU55RmZlfCvvTmyrX7IjNzU+5/em1mLP0iM0H",
	"kFnDGtWmsFth/zHjxdmxXkaVhtdCnFZluKC0pZVOV+TwYGiT7ZiXJcz9WpUNtYrjpdc0LttDL+uNHABy",
	"EHclNQ1PYSXBQEvTGf6znCE90Zn80/xTlnkMp4aA3UWLRgFnLNgvy5yl1GDvvftsvprTD1Y9oE2LHbxJ",
	"9z4FsJVSlCA1s4PSskxykdI8UZpqHOlfJcxGe6N/2WmsKju2u9oJJn9teh1hJyOIWuEmoWV5iTHeGYFG",
	"reEShjPjJ+QPlt+hKMS43T1DQ8zw3hzOKNeTRhFpMYL65P7uZmrwbWUYi++OYjWIcGIbTkFZudY2vKdI",
	"gHqCaCWIVhQz57mY1j/c3y/LBoP4fb8sLT5QJgSG4hYsmdLqAS6fNkconOfwYEJ+DsdGAVvwfGVuBStj",
	"mEth5q4rd33VFiO3hmbEe4rgdgo5MVvj0WCE95ugOFQWFiI34s5GWjGNf3FtQzIzv2/V+dsgsRC3w8SF",
	"6pPDnNVc8JdAZbnfoZw+4TgjzoTsd/tejWzMKHGCuRKtrN1PO+4aPNYoPJe0tAC6L/YSZRxVL9vIwnpN",
	"brolo4vCHJzhgNYQqiuftY3nIQoJkkIHhhe5SE9v4LxPzTj9Y4fDkwXQDCTJqKbBuXLnJX5ZY8dfsB9y",
	"BJARif5X/A/NiflsCN/wRTus0dQZ0q8I7OqZUXCt2GxnMg1Q8RaksDotMbropaB82Uze4xEWLdvwiFdW",
	"jSbYwy8Cd0gsb5xGXohlDIYXYtmjD7EEdRP0YcaJ0IdYEiNhGamMaShUy0A5XWlomSb/7/3/2Pt9P/kf",
	"mvy5mzz/t50Pn55ePHjY+/HxxY8//r/2T08ufnzwH//aM2Be1D9QKemqv38I9jb7h4hCwxEPb1kzQ2Pm",
	"3J8KebUT3znKnDTGW0LNqAHDG3dwj02rMnEUHjEA2QadgRp/WV8PCHHUHT6GrRYWjjT9DFhQZtSbwEJ7",
	"oJvGgihKlsMNnKgFVYv+IoxG/uQxOfpl/9mjx388fvaDIclSirmkBTHnSZH7ThEiSq9yeBA7E1ZPjY/+",
	"w1Nv8muPGxtHiUqmUNCyP5Q1JVqxwzYjpl0fa20046prALc5mMdgLgiLdmKt5Aa0A6aMVFNMb2QzhhCW",
	"NbNkxEGSwUZiuuzymmlW4RLlSlY3oT6ClEJGjFl4xLRIRZ6cgVRMRPwS71wL4lp4kbLs/m6hJedUETM3",
	"2lkrnoGcRLn2kiNo9aWx7rqzQx8veYObtVzfrjeyOjfvNvvSRr432ylSgkz0kpMMptW8pX3MpCgIJRl2",
	"xKv/rcjAaI6VugFu2QzWAGM2IgSBTkWlCSVcZIBqZqXifHTASYneEXTq6JA164WVtKZgVJqUVvOFJlVJ",
	"0GXR29qmY0JTuykJSkVqwKZbG+NtKzuddYDlEmhmVB3gREyd4dSZdHGRFP0t2nMix8Ujyl8LrlKKFJQy",
	"KqpVPDaC5tvZXdZr8ISAI8D1LEQJMqPyisBqoWm+AVBsEwO3FpydtbkP9XbTr9vA7uThNlJptFRLBUZK",
	"N6c7Bw1DKNwSJ2cg0er6WffPT3LV7avKgZgIJ6kcswKVXU65UJAKnqnoYDlVOtl0bE2jljhlVhCclNhJ",
	"xYEHDC6vqdLW9s54hsqRZTc4j7XEmCmGAR68UczIf/OXSX/s1PBJripV3yyqKkshNWSxNXBYrpnrLSzr",
	"ucQsGLu+vrQglYJNIw9hKRjfIcuuxCKI6tpS5ZxT/cWhPcfcA6soKltANIhYB8iRbxVgN/QLDwBiNOm6",
	"JxIOUx3KqZ3R45HSoizN+dNJxet+Q2g6sq339W9N2z5xUd3w9UyAmV17mBzk5xazNiJgQY0MjCOTgp6a",
	"uwklWusk6MNsDmOiGE8hWUf55lgemVbhEdhwSAeUCRdzFMzWORwd+o0S3SARbNiFoQUPaDbvqNQsZSVK",
	"En+F1Y0bLboTRG1cJANNmZG2gw/IwJH31v2J9fp0x7yaoLWVENoHvyeFRpaTM4UXRhv4U1ihsfudDSc4",
	"DoIQbkBSjIxqTjflBAH1TkpzIYdNYElTna/MNacXsCLnIIGoalowrW18SFuQ1KJMwgGiCv6aGZ2RzLri",
	"/Q5sY7U7wqGC5fW3YjyyYst6+I47gksLHU5gKoXIt3Am9JARhWArZwMphdl15sKRfMyKp6QWkE6IQQtp",
	"zTzvqRaacQXkv0VFUspRAKs01DeCkMhm8fo1M5gLrJ7TuRUaDEEOBVi5Er88fNhd+MOHbs+ZIjM49zF8",
	"pmEXHQ8fopb0TijdOlw3oPGa43YY4e1o+TAXhZPhujxlslG1dyNvs5PvOoPX5hJzppRyhGuWf20G0DmZ",
	"y23WHtLIgqrF5rXjuFsZNYKhY+u2+y6FmN2QIS0ew4HKiQvLMK3IrOIWqEo5dQQ9ld6gIWbjOk7Hxufv",
	"EQziWFBvjXN/Pn72w2jcBF/U382dbL9+iEiULFvGQmwyWMb2xB0x1KbuGdVjpSDq10TGLGaRKDuQp7lb",
	"WYd1kALMmVYLVpohb9dkrzSbxs2fv5hdEjPiWPySH3LrgpoJafWxlRPzxOz24dYSIINSL2Lhu6UEhazR",
	"huGWetFsKkDHhlJKcQZ8TNgEJl0Wm81BeWNSDnSGYaSoU4ht3Nr1cbD05okjwHq4kK34WIx+0EmLtImH",
	"2Sgd+eoGhBc7EJFtfHplXdmvYhbGPruDolZKQ9G3d9mufwxI+++9rNw7VILnjENSCA6raLoP4/AGP8Z6",
	"2+tuoDMKHkN9u7pEC/4OWO15ttnM6+IXdzvg7+/q0IQb2PzuuB1TZxj1jaYayEtCSZozNOQIrrSsUn3C",
	"KaqKAblG3EleAR42Hrz0TeLWiogxwQ11wim6EmsFMmoCn0HkyvoJwNsQVDWfg9IdoXkGcMJdK8ZJxZnG",
	"uQqzX4ndsBIk+nQmtmVBV2RGc7R1/AlSkGml22IkXnpKszx3dlczDRGzE0614UFKkzeMHy9xOB8D6mmG",
	"gz4X8rTGQvyKmgMHxVQS5/s/26/I/t3yF+4qwEwh+9nzm9vm+x72WOikg/zwwKlYhwcoRzcW1x7st2aG",
	"KxhPokRm5KKCcYzA79AWuW+0AU9ADxrbrdv1E66X3BDSGc1ZZmSnq5BDl8X1zqI9HR2qaW1Ex6ri1/oh",
	"FvgxF0lJ01P0Go/mTC+q6SQVxY5XLXfmolYzdzIKheD4LduhJdtRJaQ7Z482yLnX4Fckwq4uxiPHddSN",
	"G2LcwLEFdees7Zn+by3IvZ9fHZMdt1Pqno2jtkMHAbARa4CL8Wo5rMzibR6gDSQ/4Sf8AGaMM/N974Rn",
	"VNOdKVUsVTuVAvmC5pSnMJkLsufDxg6opie8x+IHU3WDgD1SVtOcpeQ0vIqbo2nTr/ojnJz8bgjk5ORD",
	"z/vRvzjdVNEzaidIzpleiEonLr8kkXBOZRYBXdX5BTiyzQ5bN+uYuLEtRbr8FTd+nFXTslTdcOP+8ssy",
	"N8sPyFC5YFqzZURpIT0TNJzRQoP7+1Y4lUvSc5+cVClQ5GNBy98Z1x9IclLt7j4B0oq//eh4jaHJVQkt",
	"u9GVwqG7NiNcuBWoYKklTUo6j0U9nZz8roGWuPt4URdoocxzgt1acb8+xgKHahbg8TG8ARaOS8cw4uKO",
	"bC+fKBxfAn7CLcQ2hjs1hv+r7lcQCXzl7epEE/d2qdKLxJzt6KqUIXG/M3X+4NzwZO+NUWzOzSFwqZZT",
	"IOkC0lPIMOsLilKvxq3u3uHnbjjPOpiy2ZE2VBFTeNDENgVSlRl1MgDlq24uhQKtfQLJeziF1bFoMoAu",
	"kzzRDulXQwcVKTW4jAyxhsfWjdHdfOc8xjDmsvSR8RgF6slir6YL32f4INsb8gYOcYwoWiHnQ4igMoII",
	"S/wDKLjCQs141yL92PKMeDO1N1/EzON5P3FNGqnNOYDD1WAkvf1eAKZai3NFplRBRoTLErZh6wEXqxSd",
	"w4DtKbRybhkc3rKM4iCb7r3oTSdm3Qutd99EQbaNE7PmKKWA+WJIBc2EHbe/n8ka0nEFE4LFPxzCpjmK",
	"SXXEgWU6VLaszbaawRBocQIGyRuBw4PRxkgo2Syo8gnMmOftz/JWMsBnTMNYl3V3GHisg2TuOqfO89zu",
	"Oe3ZbV3unU+481l2odF2i4y58cgFUcW2Q3AUgDLIYW4Xbht7QmlSQpoNMnD8OpvljANJYs5vqpRImc1A",
	"b64ZNwcY+fghIdb2RLYeIUbGAdjoIMKByVsRnk0+vwyQ3KW0UD82upaCvyEeCWjDm4zII0rDwhkfCEzz",
	"HIC6iIn6/urE7eAwhPExMWzujOaGzTkjajNILwcMxdZOxpdzUT4YEmfXmP7sxXKpNdmr6CqrCWUmD3Rc",
	"oFsD8XpRIrYFCvHlVN8aV0N36TZTD1zfQ7i6H2SPXQmAjiWiKbDkNL+NGlr7bu7fZA1LHzfp0D4yM0b7",
	"Q/QT3aUB/PUNwXW+17vudR1V0tuuy3aqWyA/xVixOSN902jfAKsgB5SIk5YEkZzGDOZGsAdkt0e+W6C5",
	"Y0Id5asHgT9cwpwpDY3pytxK3hZ72+4uign8QsyGV6dLOTPrey9EzaNtoqh134XLvPUVnAkNyYxJpRO0",
	"+0WXYBr9pFCj/Mk0jQsKbY+7rWXDsjhvwGlPYZVkLK/i9Orm/euBmfZtbYRR1fQUVigOAk0XZIq1l6Jx",
	"OGumtqFaaxf82i74Nb2x9W53GkxTM7E05NKe4xs5Fx3Ou44dRAgwRhz9XRtE6RoGiRf/AeQ6lrEUCA32",
	"cGam4WSd6bF3mDI/9jpFKYBi+I6yI0XXEmjLa1fBMPrAqHtMB6WL+mkDA2eAliXLlh1DoB11UF2kl9L2",
	"fWp4Bwu4u26wDRgIjH6xyFQJql0FoJFubRGqVkLgZCvMHLdz9UOGEE7FlC+h2EeUIW2s87UJV8dA87/C",
	"6m+mLS5ndDEeXc9uGMO1G3EDrt/V2xvFMzrErB2p5Qa4JMppWUpxRvPEWVeHSFOKM0ea2NwbY2+Z1cVt",
	"eMev9l+/c+BfjEdpDlQmtagwuCpsV34zq7IFBwYOiC/RZhQeL7NbUTLY/DoRPLTIni/AlcMKpNFe+Y7G",
	"2h4cRWehncX98hvtrc4xYJe4xkEAZe0faGxX1j3QdgnQM8pybzTy0A740HFx29WAiXKFcIBruxYCD1Fy",
	"o+ymd7rjp6Ohrg08KZxrTcGuwtakU0TwbkiWESHRFoWkWlAsvmFNAn3mxKsiMccvUTlL4wZGPlWGOLh1",
	"HJnGBBsPCKNmxIoN+CF5xYKxTDO1haLbATKYI4pMX8hlCHdT4YoJV5z9owLCMuDafJJ4KjsHFaudOFNz",
	"/zo1skN/LjewNU83w19HxggLz3RvPARivYARuql64B7UKrNfaG2OMT8E9vhLeLvDGXtX4hpPtaMPR802",
	"ZGjRdjeFtX/7/M8Qhq0Tt7nwsFdeXQWcgTmihYSZSmZS/AlxPQ/V40jYui+1wzBq8k/gk0j2T5fF1Nad",
	"ph5yM/vgdg9JN6EVqu2hH6B63PnAJ4VlTbx5lnK71bauZysuJE4wYSzXjh2/IRgHcy/+LafnUxqr+WKE",
	"DAPTfuP9bBmStSC+s8e9s3kzV/1oQgJHat2W2YSuEmSTUdJPHr6iwGCn3VpUaCQDpNpQJhhb51euRGSY",
	"ip9TbsvDmn72KLneCqzxy/Q6FxLTMVXc5p1BygqaxyWHDLHfTl/N2JzZ4qiVgqD6phvIVpW2VOQqmFr/",
	"coOawxnZHQf1fd1uZOyMKTbNAVs8si2mVCEnrw1RdRezPOB6obD54y2aLyqeScj0QlnEKkFqoQ7Vm9pz",
	"MwV9DsDJLrZ79JzcR5+VYmfwwGDR3c+jvUfP0ehq/9iNXQCuCvI6bpIhO/lPx07idIxOOzuGYdxu1Ek0",
	"udCWrh9mXGtOk+26zVnClo7XbT5LBeV0DvEwiWIDTLYv7iYa0jp44Zmtu6y0FCvCdHx+0NTwp4GYT8P+",
	"LBgkFUXBdOE8G0oUhp6a0pp2Uj+cLeLs6j95uPxHdBCW3j/SUSJv12hq77fYqtGN+5YW0EbrmFCbg5uz",
	"xnXvS7aRQ5/JjwWx6jpYFjdmLrN0FHPQkz8jpWRco2JR6VnyF5IuqKSpYX+TIXCT6Q9PI0We2lVj+OUA",
	"v3W8S1Agz+KolwNk72UI15fc54InheEo2YMmxjo4lYOezHi0mOfo3WDB9UNvK5SZUZJBcqta5EYDTn0t",
	"wuNrBrwmKdbruRQ9Xnplt06ZlYyTB63MDv32/rWTMgohY3VdmuPuJA4JWjI4w8C1+CaZMa+5FzLfaheu",
	"A/2X9Tx4kTMQy/xZjikCL8RyuA5ebUl3gdoR68DQMTUfDBlM3VBj0q7WdftOP2987jufzBcPK/7RBfYL",
	"byki2a8guokVy7O/NYk/nWKHkvJ0EXXeTE3HP5pi5fUiLTOO1oJZUM4hjw5nBZ8/vIAUEeH+Lradp2B8",
	"y7bdIol2uZ3FNYC3wfRA+QkNepnOzQQhVtuZEHXobD4XGcF5msIjDavo1+0MyqD9owKlY5mX+MGG76CR",
	"zih3tgoXAZ6hajQhP9vHhhZAWnURUCVhRZXbHHvI5iCd9bgqc0GzMTHjHL/af03srLaPrbxrq4DNUSJv",
	"r6JjnAmqFG0XCOqL6MaD1LcfZ33UrFm10limRGlalLH8I9Pi2DfAJKfQYI2yeoidCTmwapLyQridxNDD",
	"jMnCqBf1aPaiRpow/9GapgvUP1r8Y5jkty9f56lSBe8z1OWW60JDeO4M3K6CnS1gNybCKInnTNk3ZuAM",
	"2ilPdf6f0399ClR7ebLi3FJK9KJdl596FbR74GxUgrdpRyHrIP6S0qet/njZan5H2CtauaNbGrD3MINN",
	"Da8rBfu3w1LKBWcp1s2I3UPuvZptHD5blBjpWhT9EXcnNHK4ogUJ65gwh8XBEoWeETrE9S3OwVezqZY6",
	"7J8aH0ZZUE3moJXjbJCNfV1NZ/RiXIErHIVPFwV8UsiWEw05ZNQvm9T2+0uSESZADGgxP5lvb52Oi5HB",
	"p4yjNOvQ5oKQrVkKn9PQRgRmmswFKLeedn0F9bvpM8EaAxksP0z88xs4hvVBmWVbh2t/qH3vfnXuTtP2",
	"pWlLbOho/XMr1tROul+WbtLhqqtReUAv+SCCI260xPsxAuTW44ejrSG3tXETeJ8aQoMz9LpCifdwjzDq",
	"CqSdotlGQrMUhS2IjVeKJskyHgHjNePQPA4TuSDS6JWAG4PndaCfSiXVVgTciqcdA83R1RpjaEo7O/t1",
	"h+psMKIE1+jnGN7GpnjqAOOoGzSCG+Wr+k0aQ92BMPESH8NyiOyXQkWpyglRGcaOd4qjxhiHYdy+/HL7",
	"AthQ83vcdNeS2pNzmZtoKB1wWmVz0AnNsljFvRf4leBXklUoOcAS0qquWFaWJMW0+3Ydgj61uYlSwVVV",
	"rJnLN7jmdKmIydFvcQLlg+ObwScE2a9hvQev3r1/9XL/+NWBvS8UUZXNBzQyt4TCMMQJOeRKgxGdKwXk",
	"Y4jGj9jvY2fBcTCDosgRog0LM3tCxKyI6Qr/jVUVGyYgFxhx6dA8HwWBHS8t3rdH6gnn5uglis2T7TGB",
	"V9/10dFMfbXz2PS/0QOZi3kbkK/opYFwj2Js+JW538JU/l6pPHsD1pn2GAgn/AsZqN3WOaJt5ok3bq92",
	"Hjpg6lL56+0lw0Xvx3hHD4TDBkWPqBUDrEdvKCg2HYzhptqlUmlK1nJKrFQfG8FG1NgK+fZ51Kg1cyiK",
	"xgbRmM+93tsJsD11AMdei1AfntUH6K8+9pOUlDl3dcMs+ph1UeLDJrx1h67Z4O4iXOz1oBWtVxJzPYX0",
	"Yu+D/BFbuXCyfQ2H/ToWAD2UWHd+DtwVnm9H1W4d2zebQarZ2YZch/80qkUTRz/2yod9lyZIfWB1rJh/",
	"RfeSOlED0LpUhLXwBIVirg3OUKTzKazuKdKihmgpxbEn1KukCCMGsIhOYkhEqJivzVpLnPuDqZoyEAve",
	"t227Q1O/bLCGdZC5c8W5PEkSGmbzrJnyTMTUra3mMl0vleOGYU9D6RD9KrLDt9cBFu1V9fsD9TO5gShq",
	"tOpuicNzl6KMmSm1gdAnK4Pyv/k0NDuLfX65qbKN5thzKjPfIqpfeNUlGQgw7Ibs28wIFgd6Vs/Mmkik",
	"ftR6pLQHxpuluVCMz5OhoL128E/4ghu6ONGSg+V5Ea4ZSFddX/vXrRMtfOTSOjjWocK9NnYVJKjBQpUW",
	"uMEk9/dNFj/WM6P2bXPnvg0XaJQNaqCTQa798JzrkP3Sfvdh2r6e1RZqlKPXZGOyvI9BY6qHxJDqZ8Td",
	"lpvDv6+iqjDO7eMlKpZ4zw0qQ5NfKUVWpfaCDg9GoxhuW9ZiDSuJSvlpf5U9gS3HIi+vg2SaU1jtWKEp",
	"XVDeVNtpH2tbf9OuIUhe7ez2jWpxcYE1n9sFzG8Ezi+pCY1HpRB5MmDjO+zXD+iegVOWnkJGzN3hozcG",
	"6liT+2haqp0454uVz5cvS+CQPZgQYnSpotQr789pV87rTM7v6XXzL3HWrLIlPZySNjnh8cAjLLYhr8nf",
	"/DDruZoCw/yuOZUdZEOC/nKgdoGk55Gq7ts+vRjxsHQrbTdEZaGISSlXzNbc6nz3FbUI6Yd5Nhv0n9OW",
	"VmdrQ3W8KkLCDWt3gTn5ktpdP4No2+XhOpCrVQr669x6A1q4HcD9NohvTBN95A5bFPR0G4tCvI6N6Y4m",
	"DYsQLAJFEFTy8dFHImGGRSEFefgQJ3j4cOyafnzc/my0r4cPoyfz1owZrfcB3bwxivnbkBfeepoHAj46",
	"+1GxPNv4/mkYvtMUaMUAlT9ctNoXKRH7h1WR+0fVVcu8jBm1uwmImMhaW5MHUwWBOVvE5Lhuk+gLjgrS",
	"SjK9wiQ6r1GxP6LFCX6ujTDu2eA67cJF/WtxCnUaZmOyqZQvifezsC8+FuauRyO2xicsXi1pUebgDsqP",
	"96b/Dk/+8jTbffLo36d/2X22m8LTZ893d+nzp/TR8yeP4PFfnj3dhUezH55PH2ePnz6ePn389Idnz9Mn",
	"Tx9Nn/7w/N/vGT5kQLaAjnzI9ui/sI5ysv/uMDk2wDY4oSWrX64xZOxrstIUT6LRSfLRnv/pf/sTNklF",
	"0Qzvfx25iNDRQutS7e3snJ+fT8IuO3PU0RItqnSx4+fpvxjy7rAOdLJZRrijNobFkAJuqiOFffz2/tXR",
	"Mdl/dzhpCGa0N9qd7E4eYenzEjgt2Whv9AR/wtOzwH3fccQ22vt0MR7tLIDmWA/f/FGAliz1n9Q5nc9B",
	"TlxxWvPT2eMdHyex88nppxdm1HksvdCGbIXPovdqtjpbF/q9bEhWqwaaciW5xnVlPCc+8gwjaazKZ1hb",
	"jazDrKmCcxi8pexyAW1xhL3fI7XCZ2xeyc5bW7U135XNZIrYh1MleWNt7u9oehpGqyBB/qMCuWoIxrGy",
	"MKvfVzFzMS2FmpdtB3Bj6Y+9yhMrfoszm30OKLU2FTWcSMsKQkgavmp45W7y/MOnZ3+5GG0BCNot3evd",
	"H2mef7SPocESjT/th/TVOFKxC4W6cWN66LyVP0YPdv01LMpat2nHTX3kgsPHoW1wgEX3gea5aSg4xPbg",
	"A2YlICXgIXq8u/sZ3tsft0bxJPFFH+5/eoMLbXvQrr3c7nD9F8FphoUyQWm7lEff7FIOOboODMcn9ka7",
	"GI+efcN7c8gNz6E5wZZByl//FvmNn3Jxzn1LI81URUHlCmWVoJpvKJVeDN5WO2HlwZ1PLcNydq27rFd0",
	"9fBgw/V2Tw0xxX4tjE5hQ/O9Lt2HpkdXvRGWTGn1YEJ+DnsjY8bUEpu4UUnePA9WSnHGMsNinU/OZ+A2",
	"sN1TYdZN9LINtPW7e/ez3rv7batDq5hCDJgWia+Fqed5uu7F148S69Slv1Ld96CE4hUKUX3W4rjdh+SH",
	"XuzcgsHe4W7otdMB8SaAt5Z02qUvPz/ftfpbcE207oPPyJW/cWHtDc0NnQTL7USs2wojd0LcP40QVwcj",
	"2OdlsKjWOrEOK+fufPIFYW5AlHMFcbYQ4kJNN+gbFCy53+EUDya2ukvY5mrswAUWbBTPsEzPnWD2uQWz",
	"fn2rGBhN1aIvJ4whDIumANZl3nRp1au+VKGub1T6+idG1qC4ZSDdLGhdgTf2hCjHiT8bz/wuhSeHtDux",
	"6Z9abLKxfGsEp1bxORf4OSw7QfDUfPB8TyvwbLrydDgmSkgX/lRKJiTTqzFhnGRgzh56DIXEFO3m0XoX",
	"ZAQc//tm/78w9PTN/n+RH8nuuBbBMIMtMr0N7mnLQD+D7sewqRer/VocWCsLfTUCxnGNpCC6NES9Fr5+",
	"HCKtoMsfh1C2tH7FmHhW0OVorSQy/nakxesKTZ3c0z4VuXdj0env3zpqh1QpAkua6nxFKN4/Kxv7i8/p",
	"++JvbXFDizIJB4jmG62Z0T+lEssau2xUVyTBH58sWQ/fcadQVgsdrsgivlu0WTDpISMKwdWkvLvd/WZ3",
	"ty+WklKYM82wgERzn/i7qgVk86CGA3cgYHVC/ltUGOxi34uDWAVbnAGDe/2cTgANSlDn+FpfjZ2HD7sL",
	"f/jQ7TlTZAbnyEEpx4ZddDx8+B2IrMu6cCglXPCE43NmZ0CCCLk7ufWrlluf7T75ZldzBPKMpUCOoSiF",
	"pJLlK/Ibr4v0XE8sr3lOxYOySWv5Ty9SvpGiA/H9Wr7rrm+a6UYybCVOBSaE+tVJpyuPm2crjC6PxVV8",
	"wroae9cJBv5Zr4rdj3HPsTKJCemBB+fF6vBgG7n8G3GEbl3kK3Kvxffmc98A0Xia97cTT7MdM326+/T2",
	"IAh34a3Q5Cc0l31mlv5ZbQdxstqS2exMxdKehHUsh6/jOVh63BXLdDV0qe7mGaxlEQjC18Mjelpx855d",
	"s04tHAK8gu5rgWO1WyHxpx97lo6pWGL5p6vr7DfrPai3P15HVX0tuW3dIHwEexttAonLveZA21UY77ju",
	"Hde9KtdFAnT+jdqx3TC8S/DenU+eJ1xclg2jMNbUKR7gydjK5mrcd49whiWCH2zBnl+s3tqSdV8ti96v",
	"lxufzON4m2luJVz8hVgOsKs74fCLsSmD/e+FPbX0v82M6tJhN01YTah/umoVazVPy63sEwz4JsCK1Nnk",
	"Rum02rIVkfqMycywrVL5FQdxbIwdiF6jXfTe8Yc7MeZaymOXoBqOgDWZ1M4njCcJ2UHvSL4wLb+jOLQg",
	"KEeKwkflCDIDbaQns9pu7nSErfiC0sM8Zd3bWTet5uEW9dU8XIvLD8Y3nbasGoEdf7HpuhfjUQoyQny/",
	"+qKJ5jObYe2Puli4fyIOY36YfzWlfjDFPSvFlE9MdKURidnFS0H5spm8r0YiWm4isOwOwZdDcI+pvXLv",
	"19jj5RbxPaQu+ncxEvIWxSE84L5W9vfoG/ucN/LnXtBbwcEGLxqJ1dLiXZxaLS6gWQGR4ktlWZVC2ke8",
	"46JDOzLtk16y7GKnruU4JFS8wwYbhIrmpmbN2/5tHxwtS6BSXfmS3mx6OO7MeHgQBvO2Sk/WRScjoBi8",
	"XDLc7N9GW0ozmBUuZmRB1YLMKm4BrV+RxbhmH2krZuPao29Og5jtkRP+kKgFffbo8R+Pn/3g/3z87IcB",
	"eczM44rU9CWyZiDz2Q6zjVj2/camtUWJGnl7t72Vl9uh8Yhly2idOVj6cpnhuXAOcmQO9xQp6WqwPOVA",
	"pdc3IE9zt7JOJBApwFyoasHK239PUGk2jb+t+ovZJTEj9WM5h/xFzT/PQLIZPhBc84VbdrFIgAxKvVhb",
	"t8u+b1zqRbOp4F7gZ8rVRyylOAM+JmwCk27EVDZv3p3Igc7q+npCbJPPEPASQ2+eOAKshwvZRtR8F6Mf",
	"rJnh6hDftlGlifu3l5lHnuzcK1/U4qK/iMXlreAJymPAtdcNWmj5ctYXLIk4Dgyc9fNj6AauylJIFCND",
	"tqUmWwlgMBiR1OKB1qw7SMZOHEupThdVufMJ/4PlqS6aQlD2rb0da4hdJ5Ed2RY3GodtxySyzW18RTRn",
	"HBYz8oalUuxj6Ux3jaiV0lD0n9O3Xf9Y94pb9MoRPGcckkLwWDG1X/HrG/wYLc6JsZ0DnTHKdqhv9xHU",
	"FvwdsNrzbMPqrovfyddh5L2WwtJZrYSyzmXBoF+k/+a0tF5HaI5J6+edT60/nb/EtVSLSmfiPOhri5+t",
	"PVu2xY2erbciAztuu95gLMmIiwxcjbb+kaq5Rlwi9fht2nWEg5RW84W2z8HHxJCmY0JTexTsAwNqU0V2",
	"28pXHj4DQnMJNFuRKQAnYmoW3X7ZglCF7194Wcbxxnhh8QauUooUlIIsCZ8QXQdaXfkOJR+9Bk8IOAJc",
	"z0KUIDMqrwisZRLrAe0+gF6DW1sKHR/oQ73d9Os2sDt5uI1UAvEMETUaUZQ5OJ0mgsItcYKyNvvM++cn",
	"uer2VSW+UhkpjW+/HrMCi7txyoWCVPBMDT9gsenY4pMVwVqUWUFwUqKP/5mBB67W11Rp90hqq8538PCJ",
	"mWLNixtDVWvNyH+ra9b2xk4Nv+SqUs37sVb2giy2Bg7LNXO9hWU9l5gFY9fCnRZG29408hCWgvHrF2WD",
	"JzR0YMUyw0UWh5nS1IlifVS2gGgQsQ6QI98qwG5oYRkAhKkG0XVd/DblTIXIgXKrI4uyNOdPJxWv+w2h",
	"6ci23te/NW37xOUyTJGvZwJUKHg7yM8tZu1j0QuqiIODFPTUyexzl+jZh9kcxkQxnrp3f4aS+FkBR6ZV",
	"eAQ2HNKu2Bce/9Y56xyODv1GiW6QCDbswtCCY4LmVyEWXlbv69rtPqOpvC1oB+JVI2jav3fOKdPJTEj3",
	"phKdaZARr3unZCtl2ocfWq1YC2fqJjiCYyhunOCpdBVmyVkQfKa22f1+zI2Z6icht3LyN/Z4LYhZGKm4",
	"Zr7cjjlvtYz59XnM76TnO+n5Tnq+k57vpOc76flOer6Tnj+39PxlonZJkng+7V3Dsax9MvomJfxvKDH+",
	"NjPZG6G/FvlRSTAiujnHa6N5NNAcF8RyvFzL6LP1Ni0AX3hSopIpkNRMxzgpc2qkIVhqnwrZyUCqH0q3",
	"bzxhUhNV8OQxOfpl3wcqLJwnvd32vn9+WOlVDg9c1GP9CIsPfwRO8Vl2jH6kXvtJXUCJS5FgORBlcPUK",
	"Wx/AGeRGkrfOT2J0kb52dAw0f+lws0E5aj2zYUb7OG7pZA5tBS29yOPXShWhGNTSeSVjRnM1/EyGHa+g",
	"ZSyftObTVm1C1vBCZKsOuZtd28ENbBN6E6fAOJWrSBxSj7x7pKGFYT6OsPp638WNB9X0ibZPZpsoLP7e",
	"oIoeynVUHg0jqTesN5SNaJp16CT6RlQ3dmJUA7iNw9DQs98T8t72+6K3FUGI3BFrOPNXk3jSfYDZMQ1s",
	"awQqx3q+1SQRj/jo6cWzP/YP1BKmFXEUt0xMoznwxPGWZCqyVdLiTO0LJmOKKgXFdPMlE7JGPEz1vWK+",
	"rL+CvswNcRAsbh27DelhmTjeOsB4bYDYdmy3xhaO6DhvgPHPzX2HOGQIAnGsJ6Y7d0vcXpKfNdOs7nja",
	"HU8LTmPnsmfcxSZ2mcjkajxNrmTFh9nZK/uqtCLhIb2vHhiWhRhd6pblPoNpNZ/bp5S7VmgstVq/CP5l",
	"uJxd7rYM7nLEYQevU0+vmzXRHa7POIKguvtCkrkUVfnAFr7mKzRwFiXlK+/UMJp/UeUWhzbT62Z5aP2s",
	"d09u9Ma1YbvcO29+C6xP7hZt/27Rgo+B2/2FjFQ8Axl/c3fZeUl1M8aPl7zhwGtLvPgXp3urc/Nuw/39",
	"LrsMgdqRU9r39+2BaifK2zhle3Ind+nV/xw3wjtbYH6AwfajbBuGsPlikAHLwpuhU5HVXw1tfvqenof1",
	"XW9KaNxeW18A3om19hopX2vESClollKFRg0O+lzI088sS+rlYcSKjGBiGfJ+4onRSSYbhUocdyuRsp3r",
	"5bXyalowZZ9u/rLCZZNNsO8SdlvYuDPsfi+G3Rf+8ClCiaTn3cNpfTh4JrdgU/RcL3mUS+2U9hmTofjl",
	"4EC4B09uNBKjN3w7ICN4RMQ6lCEvCSVpztDdLLjSskr1Cafo0AoW1q/oXbvphkWpl75J3KcacXm6oU44",
	"xTp0tZsrKlLNIOLA/gnAS2yqms9B6Q4nngGccNeKcVJxpnGugqVSJDau31zXhqNPbMuCrsiM5uiR/ROk",
	"IFOjRISlbdE9pDTLcxcdYqYhYnbCqSY5GKb/hhmBzgznPQh1xJOluxoL8Tw/94Z5ErfO/my/Yg6dW773",
	"AqCzwn722S63nTznYWfZIOSHB67s/OEBVhJu4kJ6sN9asEDBeBIlMnPju/iqLm2R+0bG8wT0oIkwcbt+",
	"wo0wrQVBRk/11cih69TtnUV7OjpU09qIju/Xr/VDrJrFXCRGZaRz8/uc6UU1xbf+fZWLnbmoK17sZBQK",
	"wfFbtkNLtqNKSHfOHm2QD67Br0iEXd3d3N+PSzakA3Na6o3H57W6ez9wL9/AKz9f99M+GwNO7x7SuXtI",
	"5+6plbuHdO529+4hnbtnZu6emflnfWZmslZCdFW3Ntb01T3TJiUSUjtzzcDDZq3qv32vJNMTQo4Xhv9T",
	"cwfAGUiak5QqKxhxG/dcsPlCE1WlKUC2d8KTFiSpKNzE95v/WjX3pNrdfQJk90G3j7VbBJy33xdFVfyE",
	"ribyIzkZnYx6I0koxBm4WqDYPKsw/MX22jjs/6rH/VX2tq6gK2tcWdCyBHOtqWo2YymzKM+FUQbmohOt",
	"zQV+AWmAs3WPCNP2bR7EJ0a5u5gY6qqJxITu/v1+iZfF97vVaW61rNn3K2Cv41P9Dbs5Hrh27B5DvGMZ",
	"t8EyvjjT+I4qsN4VW/3KFhQ6UlvV1K8hSdVvzUfsTl5GsuZkw5txBEgryfQKbzhasj9Owfz/g+HjCuSZ",
	"v/wqmY/2Rguty72dHXwUbyGU3hmZq6n5pjofzf1A53YEd7mUkp1hreQPF/8/AAD//wY3mUCMJwEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
