// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"9P8DAAD//7vAcbmcKAEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
